{"version":3,"sources":["node_modules/node-web-gpio/dist/index.js"],"names":[],"mappings":"AAAA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scripts.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.requestGPIOAccess = exports.OperationError = exports.InvalidAccessError = exports.GPIOPort = exports.GPIOPortMap = exports.GPIOAccess = void 0;\nconst events_1 = require(\"events\");\nconst fs_1 = require(\"fs\");\nconst path = require(\"path\");\n/**\n * Interval of file system polling, in milliseconds.\n */\nconst PollingInterval = 100;\nconst SysfsGPIOPath = \"/sys/class/gpio\";\nconst GPIOPortMapSizeMax = 1024;\nconst Uint16Max = 65535;\nfunction parseUint16(string) {\n    const n = Number.parseInt(string, 10);\n    if (0 <= n && n <= Uint16Max)\n        return n;\n    else\n        throw new RangeError(`Must be between 0 and ${Uint16Max}.`);\n}\nclass GPIOAccess extends events_1.EventEmitter {\n    constructor(ports) {\n        super();\n        this._ports = ports == null ? new GPIOPortMap() : ports;\n        this._ports.forEach(port => port.on(\"change\", event => {\n            this.emit(\"change\", event);\n        }));\n        this.on(\"change\", (event) => {\n            if (this.onchange !== undefined)\n                this.onchange(event);\n        });\n    }\n    get ports() {\n        return this._ports;\n    }\n    /**\n     * Unexport all exported GPIO ports.\n     */\n    async unexportAll() {\n        await Promise.all([...this.ports.values()].map(port => port.exported ? port.unexport() : undefined));\n    }\n}\nexports.GPIOAccess = GPIOAccess;\n/**\n * Different from Web GPIO API specification.\n */\nclass GPIOPortMap extends Map {\n}\nexports.GPIOPortMap = GPIOPortMap;\nclass GPIOPort extends events_1.EventEmitter {\n    constructor(portNumber) {\n        super();\n        this._portNumber = parseUint16(portNumber.toString());\n        this._pollingInterval = PollingInterval;\n        this._direction = new OperationError(\"Unknown direction.\");\n        this._exported = new OperationError(\"Unknown export.\");\n        this.on(\"change\", (event) => {\n            if (this.onchange !== undefined)\n                this.onchange(event);\n        });\n    }\n    get portNumber() {\n        return this._portNumber;\n    }\n    get portName() {\n        return `gpio${this.portNumber}`;\n    }\n    get pinName() {\n        // NOTE: Unknown pinName.\n        return \"\";\n    }\n    get direction() {\n        if (this._direction instanceof OperationError)\n            throw this._direction;\n        return this._direction;\n    }\n    get exported() {\n        if (this._exported instanceof OperationError)\n            throw this._exported;\n        return this._exported;\n    }\n    async export(direction) {\n        if (!/^(in|out)$/.test(direction)) {\n            throw new InvalidAccessError(`Must be \"in\" or \"out\".`);\n        }\n        try {\n            await fs_1.promises.access(path.join(SysfsGPIOPath, this.portName));\n            this._exported = true;\n        }\n        catch {\n            this._exported = false;\n        }\n        try {\n            clearInterval(this._timeout);\n            if (!this.exported) {\n                await fs_1.promises.writeFile(path.join(SysfsGPIOPath, \"export\"), String(this.portNumber));\n            }\n            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, this.portName, \"direction\"), direction);\n            if (direction === \"in\") {\n                this._timeout = setInterval(this.read.bind(this), this._pollingInterval);\n            }\n        }\n        catch (error) {\n            throw new OperationError(error);\n        }\n        this._direction = direction;\n        this._exported = true;\n    }\n    async unexport() {\n        clearInterval(this._timeout);\n        try {\n            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, \"unexport\"), String(this.portNumber));\n        }\n        catch (error) {\n            throw new OperationError(error);\n        }\n        this._exported = false;\n    }\n    async read() {\n        if (!(this.exported && this.direction === \"in\")) {\n            throw new InvalidAccessError(`The exported must be true and value of direction must be \"in\".`);\n        }\n        try {\n            const buffer = await fs_1.promises.readFile(path.join(SysfsGPIOPath, this.portName, \"value\"));\n            const value = parseUint16(buffer.toString());\n            if (this._value !== value) {\n                this._value = value;\n                this.emit(\"change\", { value, port: this });\n            }\n            return value;\n        }\n        catch (error) {\n            throw new OperationError(error);\n        }\n    }\n    async write(value) {\n        if (!(this.exported && this.direction === \"out\")) {\n            throw new InvalidAccessError(`The exported must be true and value of direction must be \"out\".`);\n        }\n        try {\n            await fs_1.promises.writeFile(path.join(SysfsGPIOPath, this.portName, \"value\"), parseUint16(value.toString()).toString());\n        }\n        catch (error) {\n            throw new OperationError(error);\n        }\n    }\n}\nexports.GPIOPort = GPIOPort;\nclass InvalidAccessError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\nexports.InvalidAccessError = InvalidAccessError;\nclass OperationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n    }\n}\nexports.OperationError = OperationError;\nasync function requestGPIOAccess() {\n    const ports = new GPIOPortMap([...Array(GPIOPortMapSizeMax).keys()].map(portNumber => [\n        portNumber,\n        new GPIOPort(portNumber)\n    ]));\n    return new GPIOAccess(ports);\n}\nexports.requestGPIOAccess = requestGPIOAccess;\n"],"sourceRoot":"webpack:///"}